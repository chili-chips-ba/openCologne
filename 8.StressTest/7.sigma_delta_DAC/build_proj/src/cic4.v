// -------------------------------------------------------------
//
// Module: cic4
// Generated by MATLAB(R) 23.2 and Filter Design HDL Coder 23.2.
// Generated on: 2024-12-02 22:02:48
// -------------------------------------------------------------

// -------------------------------------------------------------
// HDL Code Generation Options:
//
// OptimizeForHDL: on
// EDAScriptGeneration: off
// AddPipelineRegisters: on
// Name: cic4
// TargetLanguage: Verilog
// TestBenchName: cic4_tb
// TestBenchStimulus: noise 

// Filter Specifications:
//
// Sample Rate          : 5.6448 MHz
// Response             : CIC
// Specification        : Fp,Ast
// Interpolation Factor : 2
// Multirate Type       : Interpolator
// Passband Edge        : 22.05 kHz
// Stopband Atten.      : 14 dB
// Differential Delay   : 1
// -------------------------------------------------------------

// -------------------------------------------------------------
// HDL Implementation    : Fully parallel
// -------------------------------------------------------------
// Filter Settings:
//
// Discrete-Time FIR Multirate Filter (real)
// -----------------------------------------
// Filter Structure      : Cascaded Integrator-Comb Interpolator
// Interpolation Factor  : 2
// Differential Delay    : 1
// Number of Sections    : 1
// Stable                : Yes
// Linear Phase          : Yes (Type 2)
//
// -------------------------------------------------------------




`timescale 1 ns / 1 ns

module cic4
               (
                clk,
                clk_enable,
                reset,
                filter_in,
                filter_out,
                ce_out
                );

  input   clk; 
  input   clk_enable; 
  input   reset; 
  input   signed [16:0] filter_in; //sfix17_En15
  output  signed [15:0] filter_out; //sfix16_En15
  output  ce_out; 

////////////////////////////////////////////////////////////////
//Module Architecture: cic4
////////////////////////////////////////////////////////////////
  // Local Functions
  // Type Definitions
  // Constants
  parameter signed [17:0] zeroconst = 18'b000000000000000000; //sfix18_En15
  // Signals
  reg  [1:0] cur_count; // ufix2
  wire phase_0; // boolean
  //   
  reg  signed [16:0] input_register; // sfix17_En15
  //   -- Section 1 Signals 
  wire signed [16:0] section_in1; // sfix17_En15
  wire signed [17:0] section_cast1; // sfix18_En15
  reg  signed [17:0] diff1; // sfix18_En15
  wire signed [17:0] section_out1; // sfix18_En15
  wire signed [17:0] sub_cast; // sfix18_En15
  wire signed [17:0] sub_cast_1; // sfix18_En15
  wire signed [18:0] sub_temp; // sfix19_En15
  reg  signed [17:0] cic_pipeline1; // sfix18_En15
  wire signed [17:0] upsampling; // sfix18_En15
  //   -- Section 2 Signals 
  wire signed [17:0] section_in2; // sfix18_En15
  wire signed [17:0] sum1; // sfix18_En15
  reg  signed [17:0] section_out2; // sfix18_En15
  wire signed [17:0] add_cast; // sfix18_En15
  wire signed [17:0] add_cast_1; // sfix18_En15
  wire signed [18:0] add_temp; // sfix19_En15
  wire signed [15:0] output_typeconvert; // sfix16_En15
  //   
  reg  signed [15:0] output_register; // sfix16_En15

  // Block Statements
  //   ------------------ CE Output Generation ------------------

  always @ (posedge clk or posedge reset)
    begin: ce_output
      if (reset == 1'b1) begin
        cur_count <= 2'b00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          if (cur_count >= 2'b01) begin
            cur_count <= 2'b00;
          end
          else begin
            cur_count <= cur_count + 2'b01;
          end
        end
      end
    end // ce_output

  assign  phase_0 = (cur_count == 2'b01 && clk_enable == 1'b1) ? 1'b1 : 1'b0;

  //   ------------------ Input Register ------------------

  always @ (posedge clk or posedge reset)
    begin: input_reg_process
      if (reset == 1'b1) begin
        input_register <= 0;
      end
      else begin
        if (phase_0 == 1'b1) begin
          input_register <= filter_in;
        end
      end
    end // input_reg_process

  //   ------------------ Section # 1 : Comb ------------------

  assign section_in1 = input_register;

  assign section_cast1 = $signed({{1{section_in1[16]}}, section_in1});

  assign sub_cast = section_cast1;
  assign sub_cast_1 = diff1;
  assign sub_temp = sub_cast - sub_cast_1;
  assign section_out1 = sub_temp[17:0];

  always @ (posedge clk or posedge reset)
    begin: comb_delay_section1
      if (reset == 1'b1) begin
        diff1 <= 0;
      end
      else begin
        if (phase_0 == 1'b1) begin
          diff1 <= section_cast1;
        end
      end
    end // comb_delay_section1

  always @ (posedge clk or posedge reset)
    begin: cic_pipeline_process_section1
      if (reset == 1'b1) begin
        cic_pipeline1 <= 0;
      end
      else begin
        if (phase_0 == 1'b1) begin
          cic_pipeline1 <= section_out1;
        end
      end
    end // cic_pipeline_process_section1

  assign upsampling = (phase_0 == 1'b1) ? cic_pipeline1 :
                zeroconst;
  //   ------------------ Section # 2 : Integrator ------------------

  assign section_in2 = upsampling;

  assign add_cast = section_in2;
  assign add_cast_1 = section_out2;
  assign add_temp = add_cast + add_cast_1;
  assign sum1 = add_temp[17:0];

  always @ (posedge clk or posedge reset)
    begin: integrator_delay_section2
      if (reset == 1'b1) begin
        section_out2 <= 0;
      end
      else begin
        if (clk_enable == 1'b1) begin
          section_out2 <= sum1;
        end
      end
    end // integrator_delay_section2

  assign output_typeconvert = section_out2[15:0];

  //   ------------------ Output Register ------------------

  always @ (posedge clk or posedge reset)
    begin: output_reg_process
      if (reset == 1'b1) begin
        output_register <= 0;
      end
      else begin
        if (clk_enable == 1'b1) begin
          output_register <= output_typeconvert;
        end
      end
    end // output_reg_process

  // Assignment Statements
  assign ce_out = phase_0;
  assign filter_out = output_register;
endmodule  // cic4
